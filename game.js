// Generated by Haxe 4.3.2
(function ($global) { "use strict";
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var GameScene = function(config) {
	this.tile_size = 32;
	this.height = 100;
	this.width = 100;
	Phaser.Scene.call(this,config);
};
GameScene.__super__ = Phaser.Scene;
GameScene.prototype = $extend(Phaser.Scene.prototype,{
	init: function() {
	}
	,preload: function() {
		this.load.atlas("terrain","terrain.png","terrain.json");
		this.load.image("player","player.png");
	}
	,create: function() {
		var tilemap = new Phaser.Tilemaps.Tilemap(this,new Phaser.Tilemaps.MapData({ width : this.width, height : this.height, tileWidth : this.tile_size, tileHeight : this.tile_size}));
		var tiles = tilemap.addTilesetImage("terrain",null,this.tile_size,this.tile_size);
		var base_layer = tilemap.createBlankLayer("terrain_base_layer",tiles);
		var terrain_texture = this.textures.get("terrain");
		var frames_names = terrain_texture.getFrameNames();
		console.log("src/GameScene.hx:45:",frames_names);
		var frames = ["grass","grass2","grass3","grass4","grass5","dirt","water"];
		var _g = 0;
		var _g1 = this.height;
		while(_g < _g1) {
			var y = _g++;
			var _g2 = 0;
			var _g3 = this.width;
			while(_g2 < _g3) {
				var r = Phaser.Math.RND.pick(frames);
				base_layer.putTileAt(frames_names.indexOf(r),_g2++,y);
			}
		}
		this.cameras.main.setBounds(0,0,this.tile_size * this.width,this.tile_size * this.height);
		this.player = this.physics.add.sprite(100,100,"player");
		this.player.setDepth(1);
		this.cameras.main.startFollow(this.player,true);
		this.keyw = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
		this.keya = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
		this.keys = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
		this.keyd = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
		var rt = this.add.renderTexture(0,0,this.width * this.tile_size,this.height * this.tile_size);
		rt.setOrigin(0,0);
		rt.setDepth(0);
		var dirt_edges = ["dirt_top","dirt_right","dirt_bottom","dirt_left","dirt_bottom_left","dirt_bottom_right","dirt_top_left","dirt_top_right"];
		var texture = this.textures.get("terrain");
		var _g = 0;
		while(_g < 5000) {
			++_g;
			var rx = Math.floor(Phaser.Math.Between(0,this.width - 1));
			var ry = Math.floor(Phaser.Math.Between(0,this.height - 1));
			var tile = tilemap.getTileAt(rx,ry);
			var e = Math.floor(Phaser.Math.Between(1,4));
			var used_edges = [];
			var _g1 = 0;
			while(_g1 < e) {
				++_g1;
				var edge = Phaser.Math.RND.pick(dirt_edges);
				while(used_edges.indexOf(edge) >= 0) edge = Phaser.Math.RND.pick(dirt_edges);
				used_edges.push(edge);
				var frame = texture.get(edge);
				rt.draw(frame,tile.pixelX,tile.pixelY);
			}
		}
	}
	,update: function(time,delta) {
		if(this.keyw.isDown) {
			this.player.setVelocityY(-400);
		} else if(this.keyd.isDown) {
			this.player.setVelocityX(400);
		} else if(this.keys.isDown) {
			this.player.setVelocityY(400);
		} else if(this.keya.isDown) {
			this.player.setVelocityX(-400);
		} else {
			this.player.setVelocity(0);
			this.player.setPosition(Math.floor(this.player.x),Math.floor(this.player.y));
		}
	}
});
var Main = function() { };
Main.main = function() {
	Main.game_scene = new GameScene({ key : "main_menu"});
	var config = { type : Phaser.AUTO, roundPixels : true, pixelArt : true, width : "100%", height : "100%", scale : { mode : Phaser.Scale.ScaleModes.RESIZE, autoCenter : Phaser.Scale.Center.CENTER_BOTH, parent : "game_canvas_wrapper", width : "100%", height : "100%"}, parent : "game_canvas_wrapper", backgroundColor : "#000", physics : { "default" : "arcade", arcade : { gravity : { y : 0}, debug : true}}, scene : Main.game_scene};
	Main.pgame = new Phaser.Game(config);
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
Main.main();
})({});
